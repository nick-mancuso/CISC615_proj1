### Test Suite: TestFunctionalityBasedApproach1.java (corresponds to RomanConverter1)
![alt text](https://github.com/nmancus1/CISC615_proj1/blob/master/img/FunctionalityBasedApproach1.png?raw=true)

### Test Suite: TestFunctionalityBasedApproach2.java (corresponds to RomanConverter2)
![alt text](https://github.com/nmancus1/CISC615_proj1/blob/master/img/TestFunctionalityBasedApproach2.png?raw=true)

### Test Suite: TestInterfaceBasedApproach1.java (corresponds to RomanConverter1)
![alt text](https://github.com/nmancus1/CISC615_proj1/blob/master/img/TestInterfaceBasedApproach1.png?raw=true)

### Test Suite: TestInterfaceBasedApproach2.java (corresponds to RomanConverter2)
![alt text](https://github.com/nmancus1/CISC615_proj1/blob/master/img/TestInterfaceBasedApproach2.png?raw=true)

### Summary
| Test Suite                           | Java File            | Line Coverage | Branch Coverage |   |
|--------------------------------------|----------------------|---------------|-----------------|---|
| TestFunctionalityBasedApproach1.java | RomanConverter1.java | 100%          | 95%             |   |
| TestFunctionalityBasedApproach2.java | RomanConverter2.java | 100%          | 85%             |   |
| TestInterfaceBasedApproach1.java     | RomanConverter1.java | 71%           | 77%             |   |
| TestInterfaceBasedApproach2.java     | RomanConverter2.java | 100%          | 85%             |   |

### Analysis

The coverage of each test suite on each implementation differs mostly in branch coverage, although
the interface based approach was lower for line coverage for `RomanConverter1`. Branch coverage
never reached 100% for any single IDM method, but overall, the average for functionality based
modeling (90%) was higher than the average of the interface based approach (81%).

Coverage differs mostly in branches; this is likely due to the implementation handling
special cases and exceptions (such as 0 and 4000), which require some domain knowledge.
The ability of the test cases to hit this code necessarily requires domain knowledge as well.
This is why functionality based IDM had better coverage when used alone. The interface
based IDM failed to produce a test case that used subtractive notation, i.e. *IV*, so the
code guarded by the `isUsingSubtractiveNotation` condition in `RomanConverter1#fromRoman`
was not hit at all. Lack of this same test case (subtractive notation) also failed to cover
the `else` branch in `RomanConverter1#toRoman` method.

When considering the test cases generated by IDM versus the test cases generated by code
coverage, the most significant difference is that there are far fewer tests generated by
the code coverage method (6 vs. ~12,000 for the given `RomanConverter` code, both achieve
100% coverage). Speaking only from naive intuition, my confidence level is *increased* 
as the number of tests goes up; but as a computer science student, I think that both test
suites might give me the same amount of confidence because they produce the same coverage. My 
intuition also tells me that adding mutation testing to our regimen would reveal some 
more significant differences.
