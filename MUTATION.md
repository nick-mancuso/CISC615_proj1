### RomanConverter1 & TestFunctionalityBasedApproach1

#### Surviving Mutations

```java
        if (arabicNumber <= 0 || arabicNumber > Utils.MAX_ROMAN) {
            throw new NoSuchElementException("Arabic numerals must be between" +
                    " 1(I) - 3,999(MMMCMXCIX) inclusive to convert to Roman numerals.");
        }

```

```bash

1. changed conditional boundary → SURVIVED

2. changed conditional boundary → SURVIVED

```

### RomanConverter1 & TestInterfaceBasedApproach1

#### Surviving Mutations

```java
        if (arabicNumber <= 0 || arabicNumber > Utils.MAX_ROMAN) {
            throw new NoSuchElementException("Arabic numerals must be between" +
                    " 1(I) - 3,999(MMMCMXCIX) inclusive to convert to Roman numerals.");
        }

```

```bash
2. changed conditional boundary → SURVIVED

```

```java
result = Utils.INTEGER_TO_ROMAN.get(n) + toRoman(arabicNumber - n);

```

```bash
 Replaced integer subtraction with addition → NO_COVERAGE

```

```java
            if (isUsingSubtractiveNotation) {
                result += Utils.ROMAN_TO_INTEGER.get(ch) - 2
                        * Utils.ROMAN_TO_INTEGER.get(input.charAt(i - 1));
            }


```

```bash
57:
1. Replaced integer subtraction with addition → NO_COVERAGE

58:
1. Replaced integer multiplication with division → NO_COVERAGE

2. Replaced integer subtraction with addition → NO_COVERAGE

3. Replaced integer addition with subtraction → NO_COVERAGE

```

```java
        for (int i = 0; i < input.length(); i++) {
            if (!Utils.ROMAN_TO_INTEGER.containsKey(input.charAt(i))) {
                result = false;
                break;
            }
        }

```

```bash

3. negated conditional → SURVIVED

```

### RomanConverter2 & TestFunctionalityBasedApproach2

#### Surviving Mutations

```java
while (!input.isEmpty() && i < romanNumerals.size())
    
```

```bash

1. changed conditional boundary → SURVIVED
```

```java

if (arabicNumber <= 0 || arabicNumber > Utils.MAX_ROMAN)

```

```bash
1. changed conditional boundary → SURVIVED

2. changed conditional boundary → SURVIVED

```

```java

while (n > 0 && i < romanNumerals.size())

```

```bash
 	

1. changed conditional boundary → SURVIVED

2. changed conditional boundary → SURVIVED

```

### RomanConverter2 & TestInterfaceBasedApproach2

#### Surviving Mutations

```java

while (!input.isEmpty() && i < romanNumerals.size())

```

```bash
1. changed conditional boundary → SURVIVED

```

```java

if (arabicNumber <= 0 || arabicNumber > Utils.MAX_ROMAN)

```

```bash
2. changed conditional boundary → SURVIVED

```

```java

while (n > 0 && i < romanNumerals.size())

```

```bash
1. changed conditional boundary → SURVIVED

2. changed conditional boundary → SURVIVED

```

### Results

| Surviving Mutations             | RomanConverter1 | RomanConverter2 |   |   |   |   |   |
|---------------------------------|-----------------|-----------------|---|---|---|---|---|
| TestInterfaceBasedApproach1     | 7               | -               |   |   |   |   |   |
| TestFunctionalityBasedApproach1 | 2               | -               |   |   |   |   |   |
| TestInterfaceBasedApproach2     | -               | 4               |   |   |   |   |   |
| TestFunctionalityBasedApproach2 | -               | 5               |   |   |   |   |   |


In the case of RomanConverter2, the interface based approach fared better than the functionality
based approach, though it was close. However, for RomanConverter1, the opposite was true. As we saw
in code coverage, using domain knowledge to generate test cases generally covered the code better.
The large discrepancy in the coverage of RomanConverter1's results is likely due to the interface
based approach not generating any test cases where subtractive notation, i.e. `IV` is used; this
caused four surviving mutants generated from the `MATH_MUTATOR` operator.

As the above report shows, the most frequently surviving mutation is generated by the
`CONDITIONALS_BOUNDARY_MUTATOR` operator, and this was true for both reports. Also, in all reports,
the `NEGATE_CONDITIONALS_MUTATOR` was reliably killed, as was the `INVERT_NEGS_MUTATOR`. I think
in the case of our Roman Converter code, these were obvious test cases to generate with either
approach.

### Test Case Augmentation

I chose to augment `TestFunctionalityBasedApproach1` which corresponds to the `RomanConverter1`
implementation. I was able to augment the suite with two additional tests, 
`testKillZeroBoundryCondition` and `testKillMaxBoundryCondition`. Through these tests I was able to
achieve 100% mutation coverage. It was simple to completely cover this implementation of 
the Roman Converter since we already had a stronger test suite from the domain knowledge
(functionality based testing).



